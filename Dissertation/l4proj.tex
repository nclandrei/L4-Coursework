\documentclass{l4proj}

\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}


\begin{document}
\title{Algorithm Animator}
\author{Andrei-Mihai Nicolae}
\maketitle

\begin{abstract}
Understanding algorithms is both very common and hard for developers in general,
regardless of their level of expertise. Even the fundamental ones, such as Dijkstra's algorithm
for finding the shortest path between two nodes in a graph, are quite complicated to grasp. Many 
studies show that visualizing an algorithm and its steps make understanding it much easier. In
this report, we will present an Algorithm Animator built specifically for solving this problem 
in a modern, responsive and efficient manner. Among others, we will also show why certain design decisions (e.g. making it a native
desktop app instead of a basic jar, using material design for the user interface), the implementation choices and the
evaluation results make this tool a viable option for software engineers when it comes to learning different kinds of 
algorithms.
\end{abstract}

\educationalconsent
\tableofcontents
%==============================================================================
\chapter{Introduction}
\label{intro}
\pagenumbering{arabic}
The travel ling salesman problem, or TSP as it is commonly known, is a combinatorial optimisation problem where, given a number of cities and 
distances from any one city to any other city, the goal is to find the shortest tour that visits all cities only once. Being an NP-complete 
problem, no algorithm is known that is able to find the optimal solution within a feasible amount of time. The lack of an algorithm for finding 
the optimal solution has resulted in many alternative heuristics and algorithms being described for providing a good approximation of the optimal 
solution. In an educational setting, trying to introduce the concepts of some of these algorithms to students that may have never encountered 
such algorithms before is not always a straightforward task.

\section{Aims}
The aim of this project is to visualise a variety of algorithms operating upon TSP instances, creating an application for use as a t
eaching aid by a lecturer to help students understand how each algorithm develops a solution. The TSP has certain properties that make 
it a good candidate for attempting to visualise the algorithms operating upon it. The problem itself is relatively simple to represent 
visually by plotting the coordinates of the cities to be visited, with edges connecting the cities to represent sections of a tour. 
One way of trying to increase the ability of students to understand new algorithms is by providing them with visual representations of 
steps or features of the algorithms. While still images could be used as visualisations, this is often not an optimal way of helping 
others to understand the execution of an algorithm. Providing animations better allows for understanding of how algorithms progress 
towards a solution, resulting in a more focused aim of this project being animations of algorithms operating upon TSP instances for 
teaching purposes.

\section{Motivation}
With the TSP being a popular problem, a large number of sample instances and optimal solutions exist in the form of the 
TSPLIB library~\cite{TSPLIBsite}, which is a good source for being able to evaluate solutions generated by the algorithms against 
optimal solutions. The amount of research into the TSP 
as a combinatorial problem has even spawned a book devoted to the subject~\cite{TSPBook}, the authors of which also developed an application known 
as Concorde~\cite{concordeSite}. Concorde is a program that is able to produce optimal solutions to TSP instances, solving 106 of the 110 TSPLIB 
instances, the largest of which is a tour through 15,112 German cities.

Attempts to visualise algorithms for educational purposes have been undertaken many times before, such as the algorithm toolkit developed by 
John Morris~\cite{algAnim}. This toolkit was essentially a framework into which new algorithms could be implemented, alongside visualisations, 
aiding students in their understanding of the algorithms. This previous evidence of visualisations being successfully developed for learning 
various algorithms suggests that using a similar approach to the visualisation of algorithms upon the TSP could result in a useful application 
covering a comprehensive range of algorithms.

\section{Contributions}


\section{Report Content}
%List these as references to each section!
The rest of the report will analyze the background of animators and why they were proven useful, as well as cover all the steps in gathering requirements, designing, implementing, testing and evaluating the tool. 

\begin{itemize}
\item Chapter~\ref{background} covers work related to the purpose of algorithm animators and why they are useful 
\item Chapter~\ref{requirements} goes into how the problem was analyzed and what requirements were gathered through
	project meetings and discussions with Algorithmics students.
\item Chapter~\ref{design} explains the design decisions behind the tool and illustrates various lessons learned and
	problems faced along the way.
\item Chapter~\ref{implementation} goes into the implementation details of the animator.
\item Chapter~\ref{testing} show how extensive unit, integration and other types of testing (e.g. smoke, end-to-end)
	were undergone and why they were essential to the development of the application.
\item Chapter~\ref{conclusions} details the overall results of the project.
\end{itemize}

%==============================================================================

\chapter{Background}
\label{background}
\section{Problem Analysis}
To derive requirements for the application, requirements gathering was undertaken during project meetings to try and define the basic 
expectations of the application.

The objective appeared to be in how to visualise algorithms that may take a large number of iterations to complete, showing them execute until 
completion in a suitable time. However, the problem is that while doing this, the application must provide informative data in the animation 
which could be easily picked up on by a viewer, such as a student, with little understanding of the algorithm, helping illustrate to them 
what the algorithm is doing.

The basic visualisation requirements given for these algorithms were that the current tour should be visible along with its cost and 
that the application should support altering of input parameters to see how modifying parameters changes the performance of algorithms. 
Algorithm-specific features were to be identified and visualised in an appropriate manner that provided a representation of the 
algorithm which students could benefit from as a learning aid.

\section{Functional Requirements}

\section{Non-Functional Requirements}
The proposed solution was to develop an application able to display animations of algorithms using the Java programming 
language. As Java provides both a large set of class libraries, including extensive graphical user interface libraries which 
support hardware rendering, this made it a perfect candidate for implementing a solution to the problem at hand. Java also has 

%==============================================================================

\chapter{Requirements}
\label{requirements}
\section{Problem Analysis}
To derive requirements for the application, requirements gathering was undertaken during project meetings to try and define the basic 
expectations of the application.

The objective appeared to be in how to visualise algorithms that may take a large number of iterations to complete, showing them execute until 
completion in a suitable time. However, the problem is that while doing this, the application must provide informative data in the animation 
which could be easily picked up on by a viewer, such as a student, with little understanding of the algorithm, helping illustrate to them 
what the algorithm is doing.

The basic visualisation requirements given for these algorithms were that the current tour should be visible along with its cost and 
that the application should support altering of input parameters to see how modifying parameters changes the performance of algorithms. 
Algorithm-specific features were to be identified and visualised in an appropriate manner that provided a representation of the 
algorithm which students could benefit from as a learning aid.

\section{Functional Requirements}

\section{Non-Functional Requirements}
The proposed solution was to develop an application able to display animations of algorithms using the Java programming 
language. As Java provides both a large set of class libraries, including extensive graphical user interface libraries which 
support hardware rendering, this made it a perfect candidate for implementing a solution to the problem at hand. Java also has 

%==============================================================================

\chapter{Design}
\label{design}
\section{Problem Analysis}
To derive requirements for the application, requirements gathering was undertaken during project meetings to try and define the basic 
expectations of the application.

The objective appeared to be in how to visualise algorithms that may take a large number of iterations to complete, showing them execute until 
completion in a suitable time. However, the problem is that while doing this, the application must provide informative data in the animation 
which could be easily picked up on by a viewer, such as a student, with little understanding of the algorithm, helping illustrate to them 
what the algorithm is doing.

The basic visualisation requirements given for these algorithms were that the current tour should be visible along with its cost and 
that the application should support altering of input parameters to see how modifying parameters changes the performance of algorithms. 
Algorithm-specific features were to be identified and visualised in an appropriate manner that provided a representation of the 
algorithm which students could benefit from as a learning aid.

\section{Functional Requirements}

\section{Non-Functional Requirements}
The proposed solution was to develop an application able to display animations of algorithms using the Java programming 
language. As Java provides both a large set of class libraries, including extensive graphical user interface libraries which 
support hardware rendering, this made it a perfect candidate for implementing a solution to the problem at hand. Java also has 

%==============================================================================

\chapter{Implementation}
\label{implementation}

\section{High-Level Overview}
The implementation of the system is based heavily upon a Model-View-Controller architecture. The model portion of the system provides 
a collection of algorithms with methods allowing them to be run, giving the ability to integrate the algorithms into a range of front-ends. 
This allows the user interface to be implemented independently of the algorithms, enabling a new interface to be placed on top of the algorithms 
and negating the need to re-implement any of the underlying algorithms specifically for a new user interface. Java's Swing GUI classes 
provide both the view and controller aspects of the architecture. The visualisation classes provide the view, while the control object classes, 
such as \texttt{JButton}, combined with \texttt{ActionListener} classes provide the control over the application. Although Swing is used for 
the front-end implementation in this project, the nature of the MVC architecture means that an interface developed in any language could be 
used, as long as it is able to communicate with the Java methods defined by the algorithms.

\subsection{Problem Instance Representation}
To represent the problem instances, a \texttt{TSPInstance} class is used. This class represents a fully connected graph 
of \texttt{AbstractCity} objects, where each city has a unique integer identifier, starting from 0, and can calculate the 
distance from itself to every other city in the instance. As several different distance calculations are used within the 
application, such as Eulerian distances, concrete classes extending \texttt{AbstractCity} must implement their own distance calculation function.

While the distance calculations could be performed on-the-fly, this gives a high constant-time cost for executing the large amount 
of distance calculations required by every algorithm. Since distances are represented as floating-point values by the application, 
which are approximations of values, there is the chance that on-the-fly calculations could yield differing distances between the same 
two cities. In the application, a distance matrix is used to store the distances between any two given cities, where the rows of the 
matrix are distributed out to the subclasses of \texttt{AbstractCity} so that each city is able to know the distance from itself to 
every other city. The use of a distance matrix ensures that there is a low constant-time cost for distance lookups, and that subsequent 
distance lookups will always have yield the same value.

%==============================================================================

\chapter{Testing}
\label{testing}

\section{High-Level Overview}
The implementation of the system is based heavily upon a Model-View-Controller architecture. The model portion of the system provides 
a collection of algorithms with methods allowing them to be run, giving the ability to integrate the algorithms into a range of front-ends. 
This allows the user interface to be implemented independently of the algorithms, enabling a new interface to be placed on top of the algorithms 
and negating the need to re-implement any of the underlying algorithms specifically for a new user interface. Java's Swing GUI classes 
provide both the view and controller aspects of the architecture. The visualisation classes provide the view, while the control object classes, 
such as \texttt{JButton}, combined with \texttt{ActionListener} classes provide the control over the application. Although Swing is used for 
the front-end implementation in this project, the nature of the MVC architecture means that an interface developed in any language could be 
used, as long as it is able to communicate with the Java methods defined by the algorithms.

\subsection{Problem Instance Representation}
To represent the problem instances, a \texttt{TSPInstance} class is used. This class represents a fully connected graph 
of \texttt{AbstractCity} objects, where each city has a unique integer identifier, starting from 0, and can calculate the 
distance from itself to every other city in the instance. As several different distance calculations are used within the 
application, such as Eulerian distances, concrete classes extending \texttt{AbstractCity} must implement their own distance calculation function.

While the distance calculations could be performed on-the-fly, this gives a high constant-time cost for executing the large amount 
of distance calculations required by every algorithm. Since distances are represented as floating-point values by the application, 
which are approximations of values, there is the chance that on-the-fly calculations could yield differing distances between the same 
two cities. In the application, a distance matrix is used to store the distances between any two given cities, where the rows of the 
matrix are distributed out to the subclasses of \texttt{AbstractCity} so that each city is able to know the distance from itself to 
every other city. The use of a distance matrix ensures that there is a low constant-time cost for distance lookups, and that subsequent 
distance lookups will always have yield the same value.

%==============================================================================

\chapter{Conclusions}
\label{conclusions}

\section{High-Level Overview}
The implementation of the system is based heavily upon a Model-View-Controller architecture. The model portion of the system provides 
a collection of algorithms with methods allowing them to be run, giving the ability to integrate the algorithms into a range of front-ends. 
This allows the user interface to be implemented independently of the algorithms, enabling a new interface to be placed on top of the algorithms 
and negating the need to re-implement any of the underlying algorithms specifically for a new user interface. Java's Swing GUI classes 
provide both the view and controller aspects of the architecture. The visualisation classes provide the view, while the control object classes, 
such as \texttt{JButton}, combined with \texttt{ActionListener} classes provide the control over the application. Although Swing is used for 
the front-end implementation in this project, the nature of the MVC architecture means that an interface developed in any language could be 
used, as long as it is able to communicate with the Java methods defined by the algorithms.

\subsection{Problem Instance Representation}
To represent the problem instances, a \texttt{TSPInstance} class is used. This class represents a fully connected graph 
of \texttt{AbstractCity} objects, where each city has a unique integer identifier, starting from 0, and can calculate the 
distance from itself to every other city in the instance. As several different distance calculations are used within the 
application, such as Eulerian distances, concrete classes extending \texttt{AbstractCity} must implement their own distance calculation function.

While the distance calculations could be performed on-the-fly, this gives a high constant-time cost for executing the large amount 
of distance calculations required by every algorithm. Since distances are represented as floating-point values by the application, 
which are approximations of values, there is the chance that on-the-fly calculations could yield differing distances between the same 
two cities. In the application, a distance matrix is used to store the distances between any two given cities, where the rows of the 
matrix are distributed out to the subclasses of \texttt{AbstractCity} so that each city is able to know the distance from itself to 
every other city. The use of a distance matrix ensures that there is a low constant-time cost for distance lookups, and that subsequent 
distance lookups will always have yield the same value.

\bibliographystyle{plain}
\bibliography{l4proj}
\end{document}
